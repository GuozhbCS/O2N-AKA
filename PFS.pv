(* proverif 2.05 *)
free DataN:bitstring [private].     (*N*)
free DataTci:bitstring [private].     (*TCi*)
free DataMk:bitstring [private].    (*Mk*)
free DataAj:bitstring [private].     (*aj*)
free DataRj:bitstring [private].    (*Rj*)
free DataSkj:bitstring [private].    (*skj *)



(*communication channel *)
free U2RA : channel [private].
free D2RA : channel [private].
free U2GWN_PRIVATE : channel [private].
free D2GWN_PRIVATE : channel [private].

free U2GWN : channel.
free D2GWN : channel.

(*Constructor*)
fun XOR(bitstring, bitstring) : bitstring. (* Exclusive OR *) 
fun Concat(bitstring, bitstring) : bitstring. 
fun Hash1(bitstring) : bitstring. 
fun Hash2(bitstring, bitstring) : bitstring. 
fun Hash3(bitstring, bitstring, bitstring) : bitstring. 
fun Hash4(bitstring, bitstring, bitstring, bitstring) : bitstring. 
fun Hash5(bitstring, bitstring, bitstring, bitstring, bitstring) :bitstring. 
fun PUF(bitstring) : bitstring.
fun PDF(bitstring, bitstring, bitstring): bitstring.
fun get_aj(bitstring, bitstring): bitstring.
fun get_new_aj(bitstring, bitstring): bitstring.
fun a_mul_G(bitstring, bitstring) : bitstring.
fun aenc(bitstring,bitstring) : bitstring. 
fun get_new_SR(bitstring, bitstring): bitstring.

(*fun a_mul_G(bitstring, bitstring) : bitstring. (* a*P *) 
fun CH(bitstring, bitstring, bitstring): bitstring. 
fun get_kA_star(bitstring, bitstring, bitstring): bitstring.
fun get_m1(bitstring, bitstring, bitstring): bitstring.
fun get_new_CH(bitstring, bitstring, bitstring): bitstring.*)


(*Destructor function*)
reduc forall m1 : bitstring, m2 : bitstring; Separate1(Concat(m1, m2)) = m1. 
reduc forall m1 : bitstring, m2 : bitstring; Separate2(Concat(m1, m2)) = m2. 
reduc forall m1 : bitstring, m2 : bitstring; DXOR_getSecond(XOR(m1, m2), m1) = m2. 
reduc forall m1 : bitstring, m2 : bitstring; DXOR_getFirst(XOR(m1, m2), m2) = m1. 
reduc forall m0 : bitstring, m1 : bitstring, m2:bitstring, t1:bitstring; D_get_new_SR(get_new_aj(m2,PDF(m0,m1,t1))) = m2. 


 (*create Table*)
table UserTable(bitstring,bitstring,bitstring). 
table DeviceTable(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).

 (*eight event*)
event GWN_Device_begin(bitstring).
event Device_GWN_end(bitstring).
event GWN_User_begin(bitstring).
event User_GWN_end(bitstring).
event Device_GWN_begin(bitstring).
event GWN_Device_end(bitstring).
event User_GWN_begin(bitstring).
event GWN_User_end(bitstring).

(*query*)
query attacker(DataN).
query attacker(DataTci).
query attacker(DataMk).
query attacker(DataRj).
query attacker(DataAj).
query attacker(DataSkj).

(*correspondence assertions*)
query t:bitstring; inj-event(User_GWN_end(t)) ==> inj-event(User_GWN_begin(t)).
query t:bitstring; event(GWN_Device_end(t)) ==> event(GWN_Device_begin(t)).
query t:bitstring; event(GWN_User_end(t)) ==> event(GWN_User_begin(t)).
query t:bitstring; inj-event(Device_GWN_end(t)) ==> inj-event(Device_GWN_begin(t)).


(******************************USER******************************)
let processUser(DataRi:bitstring,DataTci:bitstring, GWN:bitstring, User:bitstring) =
	new Idi : bitstring;
	new Pwi : bitstring;
	new Bioi : bitstring;
	let Bi = Hash1(Bioi)  in
	new Ri : bitstring;
	new Pidi : bitstring;
	let Dri = XOR(Ri, Hash3(Idi,Pwi,Bi)) in
	let Logi = Hash4(Bi,Idi,Ri,Pwi) in
	
	out(U2RA, (Idi, Pidi, Ri)); 

	in(U2RA, (Dtci:bitstring));   
   (*END*U2RA*)

	(*out(U2GWN_PRIVATE,(Pidi,Ci));*)
	let Tci = DXOR_getSecond(Dtci, Ri) in 
	
	
	(******************************Step1******************************)
	event GWN_User_begin(GWN);
	(*new Idi : bitstring;
	new Pwi : bitstring;
	new Bioi : bitstring;
	let Bi = Hash1(Bioi) in
	let Ri = XOR(Dri,Hash3(Idi,Pwi,Bioi)) in *)
	let Log = Hash4(Bi,Idi,Ri,Pwi) in
	if(Log = Logi) then

	new N : bitstring;
	out(U2GWN, aenc(DataN,N));
	new T1 : bitstring;
    (*let Tci = XOR(Dtci,Ri) in*)
	let Dni = XOR(N, Hash3(Tci,Pidi,T1)) in
	let Ai = Hash4(N,Pidi,Tci,T1) in
	out(U2GWN, (Pidi,Dni,Ai,T1));
	out(U2GWN, aenc(DataTci,Tci));


    in(U2GWN,(Dsr:bitstring,Fg:bitstring,T4:bitstring)); 
    let Pidii = Separate1(DXOR_getFirst(Dsr, Hash2(N, T4))) in 
	let Sr = Separate2(DXOR_getFirst(Dsr, Hash2(N, T4))) in
	let Fgg = Hash3(N,Sr,T4) in
	if (Fgg = Fg) then
  new Seed : bitstring;
   new Idj : bitstring;
  new Tj : bitstring;
	let Mj = PDF(Seed, Idj, Tj)	in
	let Aj = get_aj(Sr, Mj) in
	let Skj = Hash3(N,Idj,Aj) in
	(*let Pidi = Pidii in*)
	event User_GWN_end(User);
	out(U2GWN, aenc(DataSkj,Skj));
	0.




(*Device***********************************************************)
let processDevice(DataRj:bitstring,DataAj:bitstring,GWN:bitstring,Device:bitstring) =
	new Idj : bitstring;
	new Cj : bitstring;
	let Rj = PUF(Cj) in
	
	out(D2RA,(Idj, Cj, Rj)); 
	(*D2RA******************************)

	in(D2RA,(Rmj:bitstring,Cmj:bitstring));

	(*out(D2GWN_PRIVATE,(IDj,Tj,Mt,Cmj));
	let Mj = DXOR_getSecond(Rmj, Ri) in *)
	(*End Device Registration********************************************************************)
	
	(*Step 3*)
	in(D2GWN,(Dcj:bitstring,Dnj:bitstring, Bj:bitstring, T2:bitstring));
	
	let Cjk = DXOR_getSecond(Dcj, Idj) in
	let Rjk = PUF(Cjk) in
	out(D2GWN, aenc(DataRj,Rjk));
	let N = DXOR_getFirst(Dnj, Hash3(Rjk,Idj,T2)) in
	let Bb = Hash5(N,Idj,Dcj,Rjk,T2) in
	if (Bb = Bj) then
	new Aj : bitstring;
	new T3 : bitstring;
	let Rjj = PUF(Hash1(XOR(Cj,T3))) in
	let Maj = XOR(Aj,Hash3(N,Rjk,T3)) in
	out(D2GWN, aenc(DataAj,Aj));
	let Dcrj = XOR(Rjj,Aj) in
	let Ej = Hash4(Rjj,Idj,Aj,T3) in
	let Skj = Hash3(N,Idj,Aj) in
	event GWN_Device_begin(GWN);
	out(D2GWN, (Maj,Dcrj,Ej, T3));
	event Device_GWN_end(Device);
	0.


(*RA Registration Center*)
let processThirdParty(xp:bitstring) =	
	(*Device Registration*)
	in(D2RA,(Idj:bitstring, Cj:bitstring, Rj:bitstring));
	new Seed : bitstring;
	new Tj : bitstring;
	let Mj = PDF(Seed,Idj,Tj) in
	let Cmj = Hash1(Mj) in
	let Rmj = XOR(Rj,Mj) in
	let Mt = a_mul_G(Mj,Tj) in
	


	insert DeviceTable(Idj,Cj,Rj,Tj,Cmj,Mt);
	out(D2RA,(Idj, Rmj,Cmj));  
    
	(*User Registration*)
	in(U2RA,(Idi:bitstring, Pidi:bitstring, Ri:bitstring));
  new Mk : bitstring;
	let Tci = Hash2(Hash1(Mk),Ri) in
	let Ci = XOR(Tci,Mk) in
	let Dtci = XOR(Tci,Mk) in
	
	insert UserTable(Pidi,Ci,Mk);
	out(U2RA,(Dtci));
	0.

(*Gateway *)
let processGWN(DataMk:bitstring,User:bitstring,GWN:bitstring, Device:bitstring)=
	in(U2GWN_PRIVATE,(Pidi:bitstring));
	(*U2GWN*)

	in (D2GWN_PRIVATE,(IDj:bitstring));
	(*D2GWN*)
     (*Step2*)
	get UserTable(=Pidi,Ci,Mk) in 
	in(U2GWN, (Dni:bitstring,Ai:bitstring,T1:bitstring));
	    
	let Tci = DXOR_getFirst(Ci, Mk) in
	out(U2GWN, aenc(DataMk,Mk));
	let N = DXOR_getFirst(Dni, Hash3(Tci,Pidi,T1)) in
	let Aa = Hash4(N,Pidi,Tci,T1) in
	if (Aa = Ai) then

	event Device_GWN_begin(Device);	
  new Idj : bitstring;
    get DeviceTable(=Idj,Cj,Rj,Tj,Cmj,Mt) in
	new T2 : bitstring;
	let Dcj = XOR(Idj,Cj) in
	let Dnj = XOR(N, Hash3(Rj,Idj,T2)) in
	let Bj = Hash5(N,Idj,Dcj,Rj,T2) in
	out(D2GWN,(Dcj,Dnj, Bj, T2));
	(*******************************************)
	
    in(D2GWN, (Maj:bitstring,Dcrj:bitstring,Ej:bitstring, T3:bitstring));
	let Aj = DXOR_getFirst(Maj, Hash3(N, Rj, T3)) in
	let Rjj = DXOR_getFirst(Dcrj, Aj) in
	let Ejj = Hash4(Rjj,Idj,Aj,T3) in
	if (Ejj = Ej) then
	event GWN_Device_end(GWN);
	event User_GWN_begin(User); 
	new Pidii : bitstring;
	new T4 : bitstring;
	new Sr : bitstring;
	let Dsr = XOR(Concat(Pidii,Sr),Hash2(N,T4)) in
	let Fg = Hash4(Pidii, N, Sr, T4) in 
	out(U2GWN,(Dsr,Fg,T4)); 
	event GWN_User_end(GWN); 
	0.

(*main*)
process 
	new GWN:bitstring; 
	new Device:bitstring; 
	new User:bitstring;
	new xp : bitstring;
	
   ( !(processThirdParty(xp)) | (!processDevice(DataRj,DataAj,GWN,Device)) | (!processUser(DataN,DataTci,GWN,User)) |(!processGWN(DataMk,User,GWN, Device)) )  